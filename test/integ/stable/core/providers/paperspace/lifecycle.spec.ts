import * as assert from 'assert';
import * as os from 'os';
import * as fs from 'fs';
import * as path from 'path';
import { PaperspaceClient, PaperspaceMachineState } from '../../../../../../src/providers/paperspace/client/client';
import { PaperspaceInstanceStateV1 } from '../../../../../../src/providers/paperspace/state';
import { getIntegTestCoreConfig } from '../../../../utils';
import { PaperspaceProviderClient } from '../../../../../../src/providers/paperspace/provider';
import { ServerRunningStatus } from '../../../../../../src/core/runner';
import { getLogger } from '../../../../../../src/log/utils';
import { PUBLIC_IP_TYPE_STATIC } from '../../../../../../src/core/const';
import { CloudypadClient } from '../../../../../../src/core/client';

// This test is run manually using an existing instance

describe('Paperspace lifecycle', () => {
    const logger = getLogger("test-paperspace-lifecycle");
    const coreConfig = getIntegTestCoreConfig();
    const paperspaceProviderClient = new PaperspaceProviderClient({ config: coreConfig });
    const instanceName = 'test-instance-paperspace-lifecycle';

    const region = "East Coast (NY2)";
    const machineType = "P4000";

    let currentMachineId: string | undefined = undefined;

    async function getCurrentTestState(): Promise<PaperspaceInstanceStateV1> {
        return paperspaceProviderClient.getInstanceState(instanceName);
    }

    async function getPaperspaceClient(): Promise<PaperspaceClient> {
        const state = await getCurrentTestState();
        return new PaperspaceClient({
            name: instanceName,
            apiKey: state.provision.input.apiKey
        });
    }

    async function waitForInstanceReadiness(scenario: string): Promise<void> {
        const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
        
        let isReady = false;
        for (let attempt = 0; attempt < 60; attempt++) {
            isReady = await instanceManager.isReady();
            if (isReady) break;
            logger.info(`Waiting for instance readiness after ${scenario}... ${attempt + 1} / 60`);
            await new Promise(resolve => setTimeout(resolve, 5000)); // wait for 5 seconds before retrying
        }
        assert.strictEqual(isReady, true);
    }
    
    it('should initialize instance state', async () => {
        assert.strictEqual(currentMachineId, undefined);

        // Find existing SSH key in home directory
        // Since Papersapce machines are using globally configured key (per account)
        // We can't rely on autogenerated keys
        const homeDir = os.homedir();
        const sshKeyNames = ['id_rsa', 'id_ed25519', 'id_ecdsa'];
        let privateKeyPath = '';
        
        for (const keyName of sshKeyNames) {
            const keyPath = path.join(homeDir, '.ssh', keyName);
            if (fs.existsSync(keyPath)) {
                privateKeyPath = keyPath;
                break;
            }
        }
        
        if (!privateKeyPath) {
            throw new Error('No SSH private key found in ~/.ssh/ (tried: id_rsa, id_ed25519, id_ecdsa)');
        }

        const apiKey = process.env.PAPERSPACE_API_KEY;
        if (!apiKey) {
            throw new Error('PAPERSPACE_API_KEY is not set');
        }

        const initializer = new PaperspaceProviderClient({config: coreConfig}).getInstanceInitializer();
        await initializer.initializeStateOnly(instanceName, {
            ssh: {
                user: "paperspace",
                privateKeyPath: privateKeyPath
            },
            machineType: machineType,
            diskSize: 100,
            publicIpType: PUBLIC_IP_TYPE_STATIC,
            region: region,
            apiKey: apiKey,
        }, {
            wolf: {
                enable: true
            }, 
        });
    })

    it('should deploy instance', async () => {
        const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
        await instanceManager.deploy();

        const paperspaceClient = await getPaperspaceClient();
        const state = await getCurrentTestState();

        assert.ok(state.provision.output?.machineId);
        currentMachineId = state.provision.output.machineId;

        const machines = await paperspaceClient.listMachines();
        const machine = machines.find(machine => machine.id === currentMachineId);
        assert.ok(machine);
        assert.strictEqual(machine.machineType, machineType);
    }).timeout(20*60*1000); // 20 minutes timeout as deployment may be long
 
    // Update not supported yet
    it('should update instance', async () => {
        const instanceUpdater = paperspaceProviderClient.getInstanceUpdater();
        await instanceUpdater.updateStateOnly({
            instanceName: instanceName,
            provisionInputs: {
                machineType: "P5000",
            }, 
        });

        const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
        await instanceManager.deploy();

        const paperspaceClient = await getPaperspaceClient();
        const state = await getCurrentTestState();

        assert.ok(state.provision.output?.machineId);
        currentMachineId = state.provision.output.machineId;

        const machines = await paperspaceClient.listMachines();
        const machine = machines.find(machine => machine.id === currentMachineId);
        assert.ok(machine);
        assert.strictEqual(machine.machineType, "P5000");

    }).timeout(20*60*1000);

    it('should have a valid instance server output with existing server', async () => {
        const state = await getCurrentTestState();
        
        assert.ok(state.provision.output?.machineId);
        currentMachineId = state.provision.output.machineId;

        const paperspaceClient = await getPaperspaceClient();
        
        const machine = await paperspaceClient.getMachine(currentMachineId);
        assert.strictEqual(machine.state, "ready");
    })

    it('should wait for instance readiness after deployment', async () => {
        await waitForInstanceReadiness('deployment');
    }).timeout(2*60*1000);

    // run twice for idempotency
    for (let i = 0; i < 2; i++) { 

        it(`should stop instance (${i+1}/2 for idempotency)`, async () => {
            const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
            await instanceManager.stop({ wait: true });

            const instanceStatus = await instanceManager.getInstanceStatus();

            assert.strictEqual(instanceStatus.configured, true);
            assert.strictEqual(instanceStatus.serverStatus, ServerRunningStatus.Stopped);
        }).timeout(20*60*1000); // 20 in timeout as stopping P4000 instances is very long
    }

    // run twice for idempotency
    for (let i = 0; i < 2; i++) { 

        it(`should start instance (${i+1}/2 for idempotency)`, async () => {
            const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
            await instanceManager.start({ wait: true });

            const instanceStatus = await instanceManager.getInstanceStatus();
            assert.strictEqual(instanceStatus.configured, true);
            assert.strictEqual(instanceStatus.provisioned, true);
            assert.strictEqual(instanceStatus.serverStatus, ServerRunningStatus.Running);

            const state = await getCurrentTestState();
            assert.ok(state.provision.output?.machineId);

            currentMachineId = state.provision.output.machineId;
        }).timeout(2*60*1000);
    }

    it('should restart instance', async () => {

        const stateBefore = await getCurrentTestState();
        const machineIdBefore = stateBefore.provision.output?.machineId;

        assert.ok(machineIdBefore);

        const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
        await instanceManager.restart({ wait: true });

        const stateAfter = await getCurrentTestState();
        assert.strictEqual(stateAfter.provision.output?.machineId, machineIdBefore);
    }).timeout(2*60*1000);

    it('should wait for instance readiness after restart', async () => {
        await waitForInstanceReadiness('restart');
    }).timeout(2*60*1000);

    it('should destroy instance', async () => {
        const instanceManager = await paperspaceProviderClient.getInstanceManager(instanceName);
        await instanceManager.destroy();
    }).timeout(20*60*1000); // large timeout as destroying P4000 instances is very long

    it('instance does not exist after destroy', async () => {
        const coreClient = new CloudypadClient({ config: coreConfig });
        const instances = await coreClient.getAllInstances();
        assert.strictEqual(instances.find(instance => instance === instanceName), undefined);
    });
    

}).timeout(30*60*1000); // 30 minutes timeout as deployment and stopping instances may be long