import { getLogger, Logger } from "../log/utils"
import { CLOUDYPAD_SUNSHINE_PORTS, CLOUDYPAD_WOLF_PORTS, SimplePortDefinition } from "./const"
import { CommonProvisionInputV1, CommonProvisionOutputV1, CommonConfigurationInputV1 } from "./state/state"
import { confirm } from '@inquirer/prompts'

export interface InstanceProvisionOptions  {
    autoApprove?: boolean
}

export interface DestroyOptions {
    autoApprove?: boolean
}

/**
 * Provision instances: manage Cloud resources and infrastructure
 */
export interface InstanceProvisioner  {

    /**
     * Verify local provider config is valid to run other operations.
     * Throw an exception if config is invalid. 
     */
    verifyConfig(): Promise<void>

    /**
     * Provision the instance: create and update infrastructure and Cloud resources. 
     * @param opts 
     * @returns Outputs after provision
     */
    provision(opts?: InstanceProvisionOptions): Promise<CommonProvisionOutputV1>

    /**
     * Destroy the instance. Every infrastructure and Cloud resources managed for this instance are destroyed. 
     * @param opts 
     */
    destroy(opts?: DestroyOptions): Promise<void>
}

export interface InstanceProvisionerArgs<PC extends CommonProvisionInputV1, PO extends CommonProvisionOutputV1> {
    instanceName: string
    provisionInput: PC
    provisionOutput?: PO
    configurationInput: CommonConfigurationInputV1
}

export abstract class AbstractInstanceProvisioner<PC extends CommonProvisionInputV1, PO extends CommonProvisionOutputV1> implements InstanceProvisioner {
    
    protected logger: Logger
    protected args: InstanceProvisionerArgs<PC, PO>

    constructor(args: InstanceProvisionerArgs<PC, PO>){
        this.logger = getLogger(args.instanceName)
        this.args = args
    }

    async verifyConfig(): Promise<void> {
        this.logger.info(`Verifying configuration for instance ${this.args.instanceName}`);
        await this.doVerifyConfig();
    }

    async provision(opts?: InstanceProvisionOptions): Promise<PO> {
        this.logger.info(`Provisioning instance ${this.args.instanceName}`);
        return await this.doProvision(opts);
    }

    async destroy(opts?: DestroyOptions): Promise<void> {
        this.logger.info(`Destroying instance: ${this.args.instanceName}`)

        let autoApprove = opts?.autoApprove
        if(opts?.autoApprove === undefined){
            autoApprove = await confirm({
                message: `You are about to destroy instance '${this.args.instanceName}'. Please confirm:`,
                default: false,
            })
        }

        if (!autoApprove) {
            throw new Error('Destroy aborted.')
        }

        this.logger.info(`Destroying instance ${this.args.instanceName}...`)
        
        await this.doDestroy()

        this.logger.info(`Destroyed instance ${this.args.instanceName}`)
    }

    protected abstract doVerifyConfig(): Promise<void>;
    protected abstract doProvision(opts?: InstanceProvisionOptions): Promise<PO>;
    protected abstract doDestroy(): Promise<void>;

    /**
     * Transform args into a human readable string, eg.
     * { ssh: { key: '~/.ssh/id_ed25519', user: 'ubuntu' }, instanceName: 'my-instance' } into
     * SSH Key: ~/.ssh/id_ed25519
     * SSH User: ubuntu
     * Instance Name: my-instance
     * 
     */
    protected inputToHumanReadableString(args: InstanceProvisionerArgs<PC, PO>): string {

        // Shamelessly generated by IA and edited/commented by hand
        const humanReadableArgs = (obj?: any, parentKey?: string): string => {

            if(obj === undefined){
                return ""
            }

            return Object.keys(obj).map(key => {
                
                // If parent key is not empty, add a dot between parent key and current key
                // Otherwise, use current key (only for first level iteration)
                const fullKey = parentKey ? `${parentKey} ${key}` : key;

                // If value is an object, recursively transform it
                if (typeof obj[key] === 'object' && obj[key] !== null && obj[key] !== undefined) {
                    return humanReadableArgs(obj[key], fullKey);
                }

                // Tranform original key into human readable key, with MAJ on first letter of each word
                let humanReadableKey = fullKey.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())

                if(humanReadableKey.startsWith("Ssh")){
                    humanReadableKey = humanReadableKey.replace("Ssh", "SSH")
                }

                if(humanReadableKey.startsWith("Ip")){
                    humanReadableKey = humanReadableKey.replace("Ip", "IP")
                }

                // Transform value into human readable value (don't transform raw type into string)
                const humanReadableValue =
                    typeof obj[key] === 'boolean' ? obj[key] ? 'Yes' : 'No' : 
                    obj[key] === undefined || obj[key] === null ? 'None' : 
                    String(obj[key])
                return `${humanReadableKey}: ${humanReadableValue}`;
            }).join('\n    ');
        };

        const provision = humanReadableArgs(this.args.provisionInput)
        const configuration = humanReadableArgs(this.args.configurationInput)
        return `${provision}\n    ${configuration}`
    }

    /**
     * Return ports to expose on this instance for its current streaming server
     */
    protected getStreamingServerPorts(): SimplePortDefinition[] {
        if (this.args.configurationInput.sunshine?.enable) {
            return CLOUDYPAD_SUNSHINE_PORTS
        } else if (this.args.configurationInput.wolf?.enable) {
            return CLOUDYPAD_WOLF_PORTS
        } else {
            throw new Error(`Can't define ports to expose for instance ${this.args.instanceName}: unknown streaming server. This is probably a bug.`)
        }
    }

}

/**
 * Generic options for cost alert used by providers supporting automated cost alert setup.
 */
export interface CostAlertOptions {

    /**
     * Cost alert limit (USD).
     */
    limit: number

    /**
     * Cost alert notification email.
     */
    notificationEmail: string
}