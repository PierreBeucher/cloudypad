/* tslint:disable */
/* eslint-disable */
/**
 * Paperspace OpenAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * A session object containing the current team and user. If a user is not logged in, this will be null.
 * @export
 * @interface AuthSession200Response
 */
export interface AuthSession200Response {
    /**
     * 
     * @type {AuthSession200ResponseUser}
     * @memberof AuthSession200Response
     */
    'user': AuthSession200ResponseUser;
    /**
     * 
     * @type {AuthSession200ResponseTeam}
     * @memberof AuthSession200Response
     */
    'team': AuthSession200ResponseTeam;
}
/**
 * 
 * @export
 * @interface AuthSession200ResponseTeam
 */
export interface AuthSession200ResponseTeam {
    /**
     * The namespace for the team
     * @type {string}
     * @memberof AuthSession200ResponseTeam
     */
    'namespace': string;
    /**
     * Whether the team is private or not
     * @type {boolean}
     * @memberof AuthSession200ResponseTeam
     */
    'isPrivate': boolean;
    /**
     * The maximum number of machines
     * @type {number}
     * @memberof AuthSession200ResponseTeam
     */
    'maxMachines': number;
    /**
     * A unique ID for the team
     * @type {string}
     * @memberof AuthSession200ResponseTeam
     */
    'id': string;
    /**
     * An internal, numeric ID for the team
     * @type {number}
     * @memberof AuthSession200ResponseTeam
     */
    'analyticsId': number;
}
/**
 * 
 * @export
 * @interface AuthSession200ResponseUser
 */
export interface AuthSession200ResponseUser {
    /**
     * The user\'s first name
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'firstName': string | null;
    /**
     * The user\'s last name
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'lastName': string | null;
    /**
     * The user\'s email address
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'email': string;
    /**
     * The date the user was created
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'dtCreated': string;
    /**
     * The date the account was confirmed
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'dtConfirmed': string | null;
    /**
     * The teams this user is a member of
     * @type {Array<AuthSession200ResponseUserTeamMembershipsInner>}
     * @memberof AuthSession200ResponseUser
     */
    'teamMemberships': Array<AuthSession200ResponseUserTeamMembershipsInner>;
    /**
     * Whether the user\'s phone number has been verified
     * @type {boolean}
     * @memberof AuthSession200ResponseUser
     */
    'isPhoneVerified': boolean;
    /**
     * Whether the user has a password set
     * @type {boolean}
     * @memberof AuthSession200ResponseUser
     */
    'isPasswordAuthEnabled': boolean;
    /**
     * Whether the user has a QR code based MFA enabled
     * @type {boolean}
     * @memberof AuthSession200ResponseUser
     */
    'isQrCodeBasedMfaEnabled': boolean;
    /**
     * Whether the user has a QR code based MFA confirmed
     * @type {boolean}
     * @memberof AuthSession200ResponseUser
     */
    'isQrCodeBasedMfaConfirmed': boolean;
    /**
     * 
     * @type {AuthSession200ResponseUserPreferences}
     * @memberof AuthSession200ResponseUser
     */
    'preferences'?: AuthSession200ResponseUserPreferences | null;
    /**
     * A unique ID for the user
     * @type {string}
     * @memberof AuthSession200ResponseUser
     */
    'id': string;
    /**
     * An internal, numeric ID for the user
     * @type {number}
     * @memberof AuthSession200ResponseUser
     */
    'analyticsId': number;
    /**
     * 
     * @type {AuthSession200ResponseUserMetadata}
     * @memberof AuthSession200ResponseUser
     */
    'metadata': AuthSession200ResponseUserMetadata;
}
/**
 * Metadata about the user
 * @export
 * @interface AuthSession200ResponseUserMetadata
 */
export interface AuthSession200ResponseUserMetadata {
    /**
     * Tags for the user
     * @type {string}
     * @memberof AuthSession200ResponseUserMetadata
     */
    'tags'?: string | null;
    /**
     * Core survey question-answer pairs
     * @type {{ [key: string]: string; }}
     * @memberof AuthSession200ResponseUserMetadata
     */
    'coreSurvey'?: { [key: string]: string; } | null;
    /**
     * Gradient survey question-answer pairs
     * @type {{ [key: string]: string; }}
     * @memberof AuthSession200ResponseUserMetadata
     */
    'gradientSurvey'?: { [key: string]: string; } | null;
    /**
     * Whether the user has accepted the Graphcore terms of service
     * @type {boolean}
     * @memberof AuthSession200ResponseUserMetadata
     */
    'graphcoreTermsAccepted'?: boolean;
}
/**
 * The user\'s preferences
 * @export
 * @interface AuthSession200ResponseUserPreferences
 */
export interface AuthSession200ResponseUserPreferences {
    /**
     * 
     * @type {string}
     * @memberof AuthSession200ResponseUserPreferences
     */
    'defaultProduct'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthSession200ResponseUserPreferences
     */
    'defaultTeamId'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AuthSession200ResponseUserPreferences
     */
    'theme'?: AuthSession200ResponseUserPreferencesThemeEnum | null;
    /**
     * 
     * @type {number}
     * @memberof AuthSession200ResponseUserPreferences
     */
    'fontSize'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof AuthSession200ResponseUserPreferences
     */
    'disableHotkeys'?: boolean | null;
}

export const AuthSession200ResponseUserPreferencesThemeEnum = {
    Light: 'light',
    Dark: 'dark'
} as const;

export type AuthSession200ResponseUserPreferencesThemeEnum = typeof AuthSession200ResponseUserPreferencesThemeEnum[keyof typeof AuthSession200ResponseUserPreferencesThemeEnum];

/**
 * 
 * @export
 * @interface AuthSession200ResponseUserTeamMembershipsInner
 */
export interface AuthSession200ResponseUserTeamMembershipsInner {
    /**
     * 
     * @type {AuthSession200ResponseUserTeamMembershipsInnerTeam}
     * @memberof AuthSession200ResponseUserTeamMembershipsInner
     */
    'team': AuthSession200ResponseUserTeamMembershipsInnerTeam;
    /**
     * Whether the user is the owner of the team
     * @type {boolean}
     * @memberof AuthSession200ResponseUserTeamMembershipsInner
     */
    'isOwner': boolean;
    /**
     * Whether the user is an admin of the team
     * @type {boolean}
     * @memberof AuthSession200ResponseUserTeamMembershipsInner
     */
    'isAdmin': boolean;
}
/**
 * The team the user is a member of
 * @export
 * @interface AuthSession200ResponseUserTeamMembershipsInnerTeam
 */
export interface AuthSession200ResponseUserTeamMembershipsInnerTeam {
    /**
     * The name of the team
     * @type {string}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'name': string;
    /**
     * The ID of the team
     * @type {string}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'id': string;
    /**
     * The namespace of the team
     * @type {string}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'namespace': string;
    /**
     * The URL of the team\'s profile image.
     * @type {string}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'publicProfileImageUrl'?: string | null;
    /**
     * Whether the team is the user\'s team
     * @type {boolean}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'isUserTeam': boolean;
    /**
     * The date the team was created
     * @type {string}
     * @memberof AuthSession200ResponseUserTeamMembershipsInnerTeam
     */
    'dtCreated': string;
}
/**
 * 
 * @export
 * @interface AuthSessionDefaultResponse
 */
export interface AuthSessionDefaultResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthSessionDefaultResponse
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof AuthSessionDefaultResponse
     */
    'code': string;
    /**
     * 
     * @type {object}
     * @memberof AuthSessionDefaultResponse
     */
    'details'?: object;
}
/**
 * 
 * @export
 * @interface MachinesCreate200Response
 */
export interface MachinesCreate200Response {
    /**
     * 
     * @type {MachinesCreate200ResponseEvent}
     * @memberof MachinesCreate200Response
     */
    'event': MachinesCreate200ResponseEvent;
    /**
     * 
     * @type {MachinesCreate200ResponseData}
     * @memberof MachinesCreate200Response
     */
    'data': MachinesCreate200ResponseData;
}
/**
 * The machine.
 * @export
 * @interface MachinesCreate200ResponseData
 */
export interface MachinesCreate200ResponseData {
    /**
     * The ID of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'id': string;
    /**
     * The name of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'name': string;
    /**
     * The state of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'state': MachinesCreate200ResponseDataStateEnum;
    /**
     * The operating system of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'os': string;
    /**
     * The type of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'machineType': string;
    /**
     * The agent type of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'agentType': string;
    /**
     * The number of CPUs.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'cpus': number;
    /**
     * The amount of RAM in bytes.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'ram': number;
    /**
     * The total amount of storage.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'storageTotal': number;
    /**
     * The amount of storage used.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'storageUsed': number;
    /**
     * The accelerators of the machine.
     * @type {Array<MachinesList200ResponseItemsInnerAcceleratorsInner>}
     * @memberof MachinesCreate200ResponseData
     */
    'accelerators'?: Array<MachinesList200ResponseItemsInnerAcceleratorsInner> | null;
    /**
     * 
     * @type {MachinesList200ResponseItemsInnerRegion}
     * @memberof MachinesCreate200ResponseData
     */
    'region': MachinesList200ResponseItemsInnerRegion;
    /**
     * The private IP address of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'privateIp': string | null;
    /**
     * The ID of the network the machine is on.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'networkId': string | null;
    /**
     * The public IP address of the machine.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'publicIp': string | null;
    /**
     * The public IP type.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'publicIpType': MachinesCreate200ResponseDataPublicIpTypeEnum;
    /**
     * Whether auto shutdown is enabled.
     * @type {boolean}
     * @memberof MachinesCreate200ResponseData
     */
    'autoShutdownEnabled': boolean;
    /**
     * The shutdown timeout of the machine in hours.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'autoShutdownTimeout': number | null;
    /**
     * Whether to force shutdown the machine.
     * @type {boolean}
     * @memberof MachinesCreate200ResponseData
     */
    'autoShutdownForce': boolean | null;
    /**
     * Whether auto snapshots are enabled.
     * @type {boolean}
     * @memberof MachinesCreate200ResponseData
     */
    'autoSnapshotEnabled': boolean;
    /**
     * The frequency of auto snapshots.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'autoSnapshotFrequency': MachinesCreate200ResponseDataAutoSnapshotFrequencyEnum | null;
    /**
     * The number of auto snapshots to save.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'autoSnapshotSaveCount': number | null;
    /**
     * Whether updates are pending.
     * @type {boolean}
     * @memberof MachinesCreate200ResponseData
     */
    'updatesPending': boolean;
    /**
     * Whether a restore point is enabled.
     * @type {boolean}
     * @memberof MachinesCreate200ResponseData
     */
    'restorePointEnabled': boolean;
    /**
     * The frequency of restore points.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'restorePointFrequency': MachinesCreate200ResponseDataRestorePointFrequencyEnum | null;
    /**
     * The ID of the snapshot to use as a restore point.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'restorePointSnapshotId': string | null;
    /**
     * The usage rate of the machine.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'usageRate': number;
    /**
     * The storage rate of the machine.
     * @type {number}
     * @memberof MachinesCreate200ResponseData
     */
    'storageRate': number;
    /**
     * The date the machine was created.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'dtCreated': string;
    /**
     * The date the machine was last modified.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'dtModified': string;
    /**
     * The date the machine was deleted.
     * @type {string}
     * @memberof MachinesCreate200ResponseData
     */
    'dtDeleted': string | null;
    /**
     * 
     * @type {MachinesList200ResponseItemsInnerReservation}
     * @memberof MachinesCreate200ResponseData
     */
    'reservation': MachinesList200ResponseItemsInnerReservation | null;
}

export const MachinesCreate200ResponseDataStateEnum = {
    Off: 'off',
    Starting: 'starting',
    Stopping: 'stopping',
    Restarting: 'restarting',
    Serviceready: 'serviceready',
    Ready: 'ready',
    Upgrading: 'upgrading',
    Provisioning: 'provisioning'
} as const;

export type MachinesCreate200ResponseDataStateEnum = typeof MachinesCreate200ResponseDataStateEnum[keyof typeof MachinesCreate200ResponseDataStateEnum];
export const MachinesCreate200ResponseDataPublicIpTypeEnum = {
    Static: 'static',
    Dynamic: 'dynamic',
    None: 'none'
} as const;

export type MachinesCreate200ResponseDataPublicIpTypeEnum = typeof MachinesCreate200ResponseDataPublicIpTypeEnum[keyof typeof MachinesCreate200ResponseDataPublicIpTypeEnum];
export const MachinesCreate200ResponseDataAutoSnapshotFrequencyEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type MachinesCreate200ResponseDataAutoSnapshotFrequencyEnum = typeof MachinesCreate200ResponseDataAutoSnapshotFrequencyEnum[keyof typeof MachinesCreate200ResponseDataAutoSnapshotFrequencyEnum];
export const MachinesCreate200ResponseDataRestorePointFrequencyEnum = {
    Shutdown: 'shutdown'
} as const;

export type MachinesCreate200ResponseDataRestorePointFrequencyEnum = typeof MachinesCreate200ResponseDataRestorePointFrequencyEnum[keyof typeof MachinesCreate200ResponseDataRestorePointFrequencyEnum];

/**
 * The machine event to poll for the async operation.
 * @export
 * @interface MachinesCreate200ResponseEvent
 */
export interface MachinesCreate200ResponseEvent {
    /**
     * The ID of the event.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'id': string;
    /**
     * The name of the event, e.g. \"create\".
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'name': MachinesCreate200ResponseEventNameEnum;
    /**
     * The state of the event, e.g. \"done\".
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'state': MachinesCreate200ResponseEventStateEnum;
    /**
     * The ID of the machine the event is for.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'machineId': string | null;
    /**
     * The date the event was created.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'dtCreated': string;
    /**
     * The date the event was started.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'dtStarted': string | null;
    /**
     * The date the event was finished.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'dtFinished': string | null;
    /**
     * The error message of the event, if any.
     * @type {string}
     * @memberof MachinesCreate200ResponseEvent
     */
    'error': string | null;
}

export const MachinesCreate200ResponseEventNameEnum = {
    BillSessions: 'bill-sessions',
    BillUpgrade: 'bill-upgrade',
    Create: 'create',
    Deactivate: 'deactivate',
    Restart: 'restart',
    SnapshotCreate: 'snapshot-create',
    SnapshotDelete: 'snapshot-delete',
    SnapshotRestore: 'snapshot-restore',
    Start: 'start',
    Stop: 'stop',
    TemplateCreate: 'template-create',
    TemplateDelete: 'template-delete',
    TemplateDistribute: 'template-distribute',
    TemplateImport: 'template-import',
    VmMigrate: 'vm-migrate',
    VmShutdownForce: 'vm-shutdown-force',
    VmUpgrade: 'vm-upgrade'
} as const;

export type MachinesCreate200ResponseEventNameEnum = typeof MachinesCreate200ResponseEventNameEnum[keyof typeof MachinesCreate200ResponseEventNameEnum];
export const MachinesCreate200ResponseEventStateEnum = {
    New: 'new',
    InProgress: 'in progress',
    Done: 'done',
    Error: 'error',
    Cancelled: 'cancelled'
} as const;

export type MachinesCreate200ResponseEventStateEnum = typeof MachinesCreate200ResponseEventStateEnum[keyof typeof MachinesCreate200ResponseEventStateEnum];

/**
 * 
 * @export
 * @interface MachinesCreateRequest
 */
export interface MachinesCreateRequest {
    /**
     * The name of the new machine.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'name': string;
    /**
     * The machine type. This must correspond to a machine type label as indicated in <a href=\'#operation/osTemplates-list\'>List OS templates</a> or <a href=\'#operation/customTemplates-list\'>List templates</a>.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'machineType': string;
    /**
     * The template ID. See <a href=\'#operation/osTemplates-list\'>List OS templates</a> or <a href=\'#operation/customTemplates-list\'>List templates</a>.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'templateId': string;
    /**
     * The network ID.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'networkId'?: string;
    /**
     * 
     * @type {MachinesCreateRequestDiskSize}
     * @memberof MachinesCreateRequest
     */
    'diskSize': MachinesCreateRequestDiskSize;
    /**
     * 
     * @type {MachinesCreateRequestRegion}
     * @memberof MachinesCreateRequest
     */
    'region': MachinesCreateRequestRegion;
    /**
     * The public IP type.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'publicIpType'?: MachinesCreateRequestPublicIpTypeEnum;
    /**
     * Whether to enable auto snapshots.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'autoSnapshotEnabled'?: boolean;
    /**
     * The auto snapshot frequency.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'autoSnapshotFrequency'?: MachinesCreateRequestAutoSnapshotFrequencyEnum;
    /**
     * The number of auto snapshots to save.
     * @type {number}
     * @memberof MachinesCreateRequest
     */
    'autoSnapshotSaveCount'?: number;
    /**
     * Whether to enable auto shutdown.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'autoShutdownEnabled'?: boolean;
    /**
     * The auto shutdown timeout in hours.
     * @type {number}
     * @memberof MachinesCreateRequest
     */
    'autoShutdownTimeout'?: number;
    /**
     * Whether to force shutdown the machine.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'autoShutdownForce'?: boolean;
    /**
     * Whether to take an initial snapshot.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'takeInitialSnapshot'?: boolean;
    /**
     * Whether to use initial snapshot as a restore point.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'restorePointEnabled'?: boolean;
    /**
     * The restore point frequency.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'restorePointFrequency'?: MachinesCreateRequestRestorePointFrequencyEnum;
    /**
     * The startup script ID.
     * @type {string}
     * @memberof MachinesCreateRequest
     */
    'startupScriptId'?: string;
    /**
     * Whether to email the password.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'emailPassword'?: boolean;
    /**
     * Whether to start the machine on creation.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'startOnCreate'?: boolean;
    /**
     * Whether to enable NVLink.
     * @type {boolean}
     * @memberof MachinesCreateRequest
     */
    'enableNvlink'?: boolean;
    /**
     * The IDs of users to grant access to the machine.
     * @type {Array<string>}
     * @memberof MachinesCreateRequest
     */
    'accessorIds'?: Array<string>;
}

export const MachinesCreateRequestPublicIpTypeEnum = {
    Static: 'static',
    Dynamic: 'dynamic',
    None: 'none'
} as const;

export type MachinesCreateRequestPublicIpTypeEnum = typeof MachinesCreateRequestPublicIpTypeEnum[keyof typeof MachinesCreateRequestPublicIpTypeEnum];
export const MachinesCreateRequestAutoSnapshotFrequencyEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type MachinesCreateRequestAutoSnapshotFrequencyEnum = typeof MachinesCreateRequestAutoSnapshotFrequencyEnum[keyof typeof MachinesCreateRequestAutoSnapshotFrequencyEnum];
export const MachinesCreateRequestRestorePointFrequencyEnum = {
    Shutdown: 'shutdown'
} as const;

export type MachinesCreateRequestRestorePointFrequencyEnum = typeof MachinesCreateRequestRestorePointFrequencyEnum[keyof typeof MachinesCreateRequestRestorePointFrequencyEnum];

/**
 * The disk size in gigabytes.
 * @export
 * @interface MachinesCreateRequestDiskSize
 */
export interface MachinesCreateRequestDiskSize {
}
/**
 * The region to create the machine in.
 * @export
 * @interface MachinesCreateRequestRegion
 */
export interface MachinesCreateRequestRegion {
}
/**
 * 
 * @export
 * @interface MachinesList200Response
 */
export interface MachinesList200Response {
    /**
     * Whether there are more pages of results available.
     * @type {boolean}
     * @memberof MachinesList200Response
     */
    'hasMore': boolean;
    /**
     * The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
     * @type {string}
     * @memberof MachinesList200Response
     */
    'nextPage'?: string;
    /**
     * The items on this page.
     * @type {Array<MachinesList200ResponseItemsInner>}
     * @memberof MachinesList200Response
     */
    'items': Array<MachinesList200ResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface MachinesList200ResponseItemsInner
 */
export interface MachinesList200ResponseItemsInner {
    /**
     * The ID of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'id': string;
    /**
     * The name of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'name': string;
    /**
     * The state of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'state': MachinesList200ResponseItemsInnerStateEnum;
    /**
     * The operating system of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'os': string;
    /**
     * The type of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'machineType': string;
    /**
     * The agent type of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'agentType': string;
    /**
     * The number of CPUs.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'cpus': number;
    /**
     * The amount of RAM in bytes.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'ram': number;
    /**
     * The total amount of storage.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'storageTotal': number;
    /**
     * The amount of storage used.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'storageUsed': number;
    /**
     * The accelerators of the machine.
     * @type {Array<MachinesList200ResponseItemsInnerAcceleratorsInner>}
     * @memberof MachinesList200ResponseItemsInner
     */
    'accelerators'?: Array<MachinesList200ResponseItemsInnerAcceleratorsInner> | null;
    /**
     * 
     * @type {MachinesList200ResponseItemsInnerRegion}
     * @memberof MachinesList200ResponseItemsInner
     */
    'region': MachinesList200ResponseItemsInnerRegion;
    /**
     * The private IP address of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'privateIp': string | null;
    /**
     * The ID of the network the machine is on.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'networkId': string | null;
    /**
     * The public IP address of the machine.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'publicIp': string | null;
    /**
     * The public IP type.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'publicIpType': MachinesList200ResponseItemsInnerPublicIpTypeEnum;
    /**
     * Whether auto shutdown is enabled.
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoShutdownEnabled': boolean;
    /**
     * The shutdown timeout of the machine in hours.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoShutdownTimeout': number | null;
    /**
     * Whether to force shutdown the machine.
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoShutdownForce': boolean | null;
    /**
     * Whether auto snapshots are enabled.
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoSnapshotEnabled': boolean;
    /**
     * The frequency of auto snapshots.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoSnapshotFrequency': MachinesList200ResponseItemsInnerAutoSnapshotFrequencyEnum | null;
    /**
     * The number of auto snapshots to save.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'autoSnapshotSaveCount': number | null;
    /**
     * Whether updates are pending.
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInner
     */
    'updatesPending': boolean;
    /**
     * Whether a restore point is enabled.
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInner
     */
    'restorePointEnabled': boolean;
    /**
     * The frequency of restore points.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'restorePointFrequency': MachinesList200ResponseItemsInnerRestorePointFrequencyEnum | null;
    /**
     * The ID of the snapshot to use as a restore point.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'restorePointSnapshotId': string | null;
    /**
     * The usage rate of the machine.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'usageRate': number;
    /**
     * The storage rate of the machine.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInner
     */
    'storageRate': number;
    /**
     * The date the machine was created.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'dtCreated': string;
    /**
     * The date the machine was last modified.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'dtModified': string;
    /**
     * The date the machine was deleted.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInner
     */
    'dtDeleted': string | null;
    /**
     * 
     * @type {MachinesList200ResponseItemsInnerReservation}
     * @memberof MachinesList200ResponseItemsInner
     */
    'reservation': MachinesList200ResponseItemsInnerReservation | null;
}

export const MachinesList200ResponseItemsInnerStateEnum = {
    Off: 'off',
    Starting: 'starting',
    Stopping: 'stopping',
    Restarting: 'restarting',
    Serviceready: 'serviceready',
    Ready: 'ready',
    Upgrading: 'upgrading',
    Provisioning: 'provisioning'
} as const;

export type MachinesList200ResponseItemsInnerStateEnum = typeof MachinesList200ResponseItemsInnerStateEnum[keyof typeof MachinesList200ResponseItemsInnerStateEnum];
export const MachinesList200ResponseItemsInnerPublicIpTypeEnum = {
    Static: 'static',
    Dynamic: 'dynamic',
    None: 'none'
} as const;

export type MachinesList200ResponseItemsInnerPublicIpTypeEnum = typeof MachinesList200ResponseItemsInnerPublicIpTypeEnum[keyof typeof MachinesList200ResponseItemsInnerPublicIpTypeEnum];
export const MachinesList200ResponseItemsInnerAutoSnapshotFrequencyEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type MachinesList200ResponseItemsInnerAutoSnapshotFrequencyEnum = typeof MachinesList200ResponseItemsInnerAutoSnapshotFrequencyEnum[keyof typeof MachinesList200ResponseItemsInnerAutoSnapshotFrequencyEnum];
export const MachinesList200ResponseItemsInnerRestorePointFrequencyEnum = {
    Shutdown: 'shutdown'
} as const;

export type MachinesList200ResponseItemsInnerRestorePointFrequencyEnum = typeof MachinesList200ResponseItemsInnerRestorePointFrequencyEnum[keyof typeof MachinesList200ResponseItemsInnerRestorePointFrequencyEnum];

/**
 * 
 * @export
 * @interface MachinesList200ResponseItemsInnerAcceleratorsInner
 */
export interface MachinesList200ResponseItemsInnerAcceleratorsInner {
    /**
     * The name of the accelerator.
     * @type {string}
     * @memberof MachinesList200ResponseItemsInnerAcceleratorsInner
     */
    'name': string;
    /**
     * The amount of memory the accelerator has, if applicable.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInnerAcceleratorsInner
     */
    'memory': number | null;
    /**
     * The number of accelerators of this type.
     * @type {number}
     * @memberof MachinesList200ResponseItemsInnerAcceleratorsInner
     */
    'count': number;
}
/**
 * The region of the machine.
 * @export
 * @interface MachinesList200ResponseItemsInnerRegion
 */
export interface MachinesList200ResponseItemsInnerRegion {
}
/**
 * 
 * @export
 * @interface MachinesList200ResponseItemsInnerReservation
 */
export interface MachinesList200ResponseItemsInnerReservation {
    /**
     * 
     * @type {string}
     * @memberof MachinesList200ResponseItemsInnerReservation
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof MachinesList200ResponseItemsInnerReservation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MachinesList200ResponseItemsInnerReservation
     */
    'dtStarted': string;
    /**
     * 
     * @type {string}
     * @memberof MachinesList200ResponseItemsInnerReservation
     */
    'dtFinished': string;
    /**
     * 
     * @type {boolean}
     * @memberof MachinesList200ResponseItemsInnerReservation
     */
    'isActive': boolean;
}
/**
 * 
 * @export
 * @interface MachinesUpdate200Response
 */
export interface MachinesUpdate200Response {
    /**
     * 
     * @type {MachinesCreate200ResponseEvent}
     * @memberof MachinesUpdate200Response
     */
    'event'?: MachinesCreate200ResponseEvent;
    /**
     * 
     * @type {MachinesCreate200ResponseData}
     * @memberof MachinesUpdate200Response
     */
    'data': MachinesCreate200ResponseData;
}
/**
 * 
 * @export
 * @interface MachinesUpdateRequest
 */
export interface MachinesUpdateRequest {
    /**
     * The name of the machine.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'name'?: string;
    /**
     * The machine type. This must correspond to a machine type label as indicated in <a href=\'#operation/osTemplates-list\'>List OS templates</a> or <a href=\'#operation/customTemplates-list\'>List templates</a>.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'machineType'?: string;
    /**
     * 
     * @type {MachinesCreateRequestDiskSize}
     * @memberof MachinesUpdateRequest
     */
    'diskSize'?: MachinesCreateRequestDiskSize;
    /**
     * The network ID.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'networkId'?: string;
    /**
     * The public IP type.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'publicIpType'?: MachinesUpdateRequestPublicIpTypeEnum;
    /**
     * Whether to enable auto snapshots.
     * @type {boolean}
     * @memberof MachinesUpdateRequest
     */
    'autoSnapshotEnabled'?: boolean;
    /**
     * The auto snapshot frequency.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'autoSnapshotFrequency'?: MachinesUpdateRequestAutoSnapshotFrequencyEnum;
    /**
     * The number of auto snapshots to save.
     * @type {number}
     * @memberof MachinesUpdateRequest
     */
    'autoSnapshotSaveCount'?: number;
    /**
     * Whether to enable auto shutdown.
     * @type {boolean}
     * @memberof MachinesUpdateRequest
     */
    'autoShutdownEnabled'?: boolean;
    /**
     * The auto shutdown timeout in hours.
     * @type {number}
     * @memberof MachinesUpdateRequest
     */
    'autoShutdownTimeout'?: number;
    /**
     * Whether to force shutdown the machine.
     * @type {boolean}
     * @memberof MachinesUpdateRequest
     */
    'autoShutdownForce'?: boolean;
    /**
     * Whether to use initial snapshot as a restore point.
     * @type {boolean}
     * @memberof MachinesUpdateRequest
     */
    'restorePointEnabled'?: boolean;
    /**
     * The restore point frequency.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'restorePointFrequency'?: MachinesUpdateRequestRestorePointFrequencyEnum;
    /**
     * The restore point snapshot ID.
     * @type {string}
     * @memberof MachinesUpdateRequest
     */
    'restorePointSnapshotId'?: string;
}

export const MachinesUpdateRequestPublicIpTypeEnum = {
    Static: 'static',
    Dynamic: 'dynamic',
    None: 'none'
} as const;

export type MachinesUpdateRequestPublicIpTypeEnum = typeof MachinesUpdateRequestPublicIpTypeEnum[keyof typeof MachinesUpdateRequestPublicIpTypeEnum];
export const MachinesUpdateRequestAutoSnapshotFrequencyEnum = {
    Hourly: 'hourly',
    Daily: 'daily',
    Weekly: 'weekly',
    Monthly: 'monthly'
} as const;

export type MachinesUpdateRequestAutoSnapshotFrequencyEnum = typeof MachinesUpdateRequestAutoSnapshotFrequencyEnum[keyof typeof MachinesUpdateRequestAutoSnapshotFrequencyEnum];
export const MachinesUpdateRequestRestorePointFrequencyEnum = {
    Shutdown: 'shutdown'
} as const;

export type MachinesUpdateRequestRestorePointFrequencyEnum = typeof MachinesUpdateRequestRestorePointFrequencyEnum[keyof typeof MachinesUpdateRequestRestorePointFrequencyEnum];

/**
 * 
 * @export
 * @interface PublicIpsAssignRequest
 */
export interface PublicIpsAssignRequest {
    /**
     * The ID of the machine to assign the public IP to.
     * @type {string}
     * @memberof PublicIpsAssignRequest
     */
    'machineId': string | null;
}
/**
 * 
 * @export
 * @interface PublicIpsClaimRequest
 */
export interface PublicIpsClaimRequest {
    /**
     * 
     * @type {PublicIpsList200ResponseItemsInnerRegion}
     * @memberof PublicIpsClaimRequest
     */
    'region': PublicIpsList200ResponseItemsInnerRegion;
}
/**
 * 
 * @export
 * @interface PublicIpsList200Response
 */
export interface PublicIpsList200Response {
    /**
     * Whether there are more pages of results available.
     * @type {boolean}
     * @memberof PublicIpsList200Response
     */
    'hasMore': boolean;
    /**
     * The cursor required to fetch the next page of results. i.e. `?after=nextPage`. This is `null` when there is no next page.
     * @type {string}
     * @memberof PublicIpsList200Response
     */
    'nextPage'?: string;
    /**
     * The items on this page.
     * @type {Array<PublicIpsList200ResponseItemsInner>}
     * @memberof PublicIpsList200Response
     */
    'items': Array<PublicIpsList200ResponseItemsInner>;
}
/**
 * 
 * @export
 * @interface PublicIpsList200ResponseItemsInner
 */
export interface PublicIpsList200ResponseItemsInner {
    /**
     * The IP address of the public IP.
     * @type {string}
     * @memberof PublicIpsList200ResponseItemsInner
     */
    'ip': string;
    /**
     * 
     * @type {PublicIpsList200ResponseItemsInnerRegion}
     * @memberof PublicIpsList200ResponseItemsInner
     */
    'region': PublicIpsList200ResponseItemsInnerRegion;
    /**
     * The ID of the machine the public IP is assigned to.
     * @type {string}
     * @memberof PublicIpsList200ResponseItemsInner
     */
    'assignedMachineId'?: string;
    /**
     * The date the public IP was claimed.
     * @type {string}
     * @memberof PublicIpsList200ResponseItemsInner
     */
    'dtCreated': string;
}
/**
 * The region of the public IP.
 * @export
 * @interface PublicIpsList200ResponseItemsInnerRegion
 */
export interface PublicIpsList200ResponseItemsInnerRegion {
}
/**
 * 
 * @export
 * @interface PublicIpsListRegionParameter
 */
export interface PublicIpsListRegionParameter {
}
/**
 * 
 * @export
 * @interface PublicIpsRelease200Response
 */
export interface PublicIpsRelease200Response {
    /**
     * 
     * @type {string}
     * @memberof PublicIpsRelease200Response
     */
    'ip': string;
}

/**
 * AuthenticationApi - axios parameter creator
 * @export
 */
export const AuthenticationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the current session. If a user is not logged in, this will be null. Otherwise, it will contain the current team and user.
         * @summary Get the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSession: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/session`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthenticationApi - functional programming interface
 * @export
 */
export const AuthenticationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthenticationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the current session. If a user is not logged in, this will be null. Otherwise, it will contain the current team and user.
         * @summary Get the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSession(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSession200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSession(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthenticationApi.authSession']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthenticationApi - factory interface
 * @export
 */
export const AuthenticationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthenticationApiFp(configuration)
    return {
        /**
         * Get the current session. If a user is not logged in, this will be null. Otherwise, it will contain the current team and user.
         * @summary Get the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSession(options?: any): AxiosPromise<AuthSession200Response> {
            return localVarFp.authSession(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthenticationApi - object-oriented interface
 * @export
 * @class AuthenticationApi
 * @extends {BaseAPI}
 */
export class AuthenticationApi extends BaseAPI {
    /**
     * Get the current session. If a user is not logged in, this will be null. Otherwise, it will contain the current team and user.
     * @summary Get the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthenticationApi
     */
    public authSession(options?: RawAxiosRequestConfig) {
        return AuthenticationApiFp(this.configuration).authSession(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MachineApi - axios parameter creator
 * @export
 */
export const MachineApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a new machine.
         * @summary Create a machine
         * @param {MachinesCreateRequest} machinesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesCreate: async (machinesCreateRequest: MachinesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'machinesCreateRequest' is not null or undefined
            assertParamExists('machinesCreate', 'machinesCreateRequest', machinesCreateRequest)
            const localVarPath = `/machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a single machine by ID.
         * @summary Delete a machine
         * @param {string} id The ID of the machine to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesDelete', 'id', id)
            const localVarPath = `/machines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a single machine by ID.
         * @summary Get a machine
         * @param {string} id The ID of the machine to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesGet', 'id', id)
            const localVarPath = `/machines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of machines.
         * @summary List machines
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {MachinesListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {MachinesListOrderEnum} [order] The order to sort the results by.
         * @param {string} [name] 
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {string} [agentType] 
         * @param {string} [machineType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesList: async (after?: string, limit?: number, orderBy?: MachinesListOrderByEnum, order?: MachinesListOrderEnum, name?: string, region?: PublicIpsListRegionParameter, agentType?: string, machineType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/machines`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (region !== undefined) {
                for (const [key, value] of Object.entries(region)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (agentType !== undefined) {
                localVarQueryParameter['agentType'] = agentType;
            }

            if (machineType !== undefined) {
                localVarQueryParameter['machineType'] = machineType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restarts a machine.
         * @summary Restart a machine
         * @param {string} id The ID of the machine to restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesRestart: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesRestart', 'id', id)
            const localVarPath = `/machines/{id}/restart`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Starts a machine.
         * @summary Start a machine
         * @param {string} id The ID of the machine to start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesStart: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesStart', 'id', id)
            const localVarPath = `/machines/{id}/start`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stops a machine.
         * @summary Stop a machine
         * @param {string} id The ID of the machine to stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesStop: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesStop', 'id', id)
            const localVarPath = `/machines/{id}/stop`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a machine.
         * @summary Update a machine
         * @param {string} id The ID of the machine to update.
         * @param {MachinesUpdateRequest} machinesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesUpdate: async (id: string, machinesUpdateRequest: MachinesUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('machinesUpdate', 'id', id)
            // verify required parameter 'machinesUpdateRequest' is not null or undefined
            assertParamExists('machinesUpdate', 'machinesUpdateRequest', machinesUpdateRequest)
            const localVarPath = `/machines/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(machinesUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MachineApi - functional programming interface
 * @export
 */
export const MachineApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MachineApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a new machine.
         * @summary Create a machine
         * @param {MachinesCreateRequest} machinesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesCreate(machinesCreateRequest: MachinesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesCreate(machinesCreateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deletes a single machine by ID.
         * @summary Delete a machine
         * @param {string} id The ID of the machine to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesDelete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesDelete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a single machine by ID.
         * @summary Get a machine
         * @param {string} id The ID of the machine to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesGet(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of machines.
         * @summary List machines
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {MachinesListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {MachinesListOrderEnum} [order] The order to sort the results by.
         * @param {string} [name] 
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {string} [agentType] 
         * @param {string} [machineType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesList(after?: string, limit?: number, orderBy?: MachinesListOrderByEnum, order?: MachinesListOrderEnum, name?: string, region?: PublicIpsListRegionParameter, agentType?: string, machineType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesList(after, limit, orderBy, order, name, region, agentType, machineType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Restarts a machine.
         * @summary Restart a machine
         * @param {string} id The ID of the machine to restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesRestart(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesRestart(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesRestart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Starts a machine.
         * @summary Start a machine
         * @param {string} id The ID of the machine to start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesStart(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesStart(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesStart']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Stops a machine.
         * @summary Stop a machine
         * @param {string} id The ID of the machine to stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesStop(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesCreate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesStop(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesStop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates a machine.
         * @summary Update a machine
         * @param {string} id The ID of the machine to update.
         * @param {MachinesUpdateRequest} machinesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async machinesUpdate(id: string, machinesUpdateRequest: MachinesUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MachinesUpdate200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.machinesUpdate(id, machinesUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MachineApi.machinesUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MachineApi - factory interface
 * @export
 */
export const MachineApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MachineApiFp(configuration)
    return {
        /**
         * Creates a new machine.
         * @summary Create a machine
         * @param {MachinesCreateRequest} machinesCreateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesCreate(machinesCreateRequest: MachinesCreateRequest, options?: any): AxiosPromise<MachinesCreate200Response> {
            return localVarFp.machinesCreate(machinesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a single machine by ID.
         * @summary Delete a machine
         * @param {string} id The ID of the machine to delete.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesDelete(id: string, options?: any): AxiosPromise<MachinesCreate200Response> {
            return localVarFp.machinesDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a single machine by ID.
         * @summary Get a machine
         * @param {string} id The ID of the machine to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesGet(id: string, options?: any): AxiosPromise<MachinesList200ResponseItemsInner> {
            return localVarFp.machinesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of machines.
         * @summary List machines
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {MachinesListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {MachinesListOrderEnum} [order] The order to sort the results by.
         * @param {string} [name] 
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {string} [agentType] 
         * @param {string} [machineType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesList(after?: string, limit?: number, orderBy?: MachinesListOrderByEnum, order?: MachinesListOrderEnum, name?: string, region?: PublicIpsListRegionParameter, agentType?: string, machineType?: string, options?: any): AxiosPromise<MachinesList200Response> {
            return localVarFp.machinesList(after, limit, orderBy, order, name, region, agentType, machineType, options).then((request) => request(axios, basePath));
        },
        /**
         * Restarts a machine.
         * @summary Restart a machine
         * @param {string} id The ID of the machine to restart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesRestart(id: string, options?: any): AxiosPromise<MachinesCreate200Response> {
            return localVarFp.machinesRestart(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Starts a machine.
         * @summary Start a machine
         * @param {string} id The ID of the machine to start.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesStart(id: string, options?: any): AxiosPromise<MachinesCreate200Response> {
            return localVarFp.machinesStart(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Stops a machine.
         * @summary Stop a machine
         * @param {string} id The ID of the machine to stop.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesStop(id: string, options?: any): AxiosPromise<MachinesCreate200Response> {
            return localVarFp.machinesStop(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a machine.
         * @summary Update a machine
         * @param {string} id The ID of the machine to update.
         * @param {MachinesUpdateRequest} machinesUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        machinesUpdate(id: string, machinesUpdateRequest: MachinesUpdateRequest, options?: any): AxiosPromise<MachinesUpdate200Response> {
            return localVarFp.machinesUpdate(id, machinesUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MachineApi - object-oriented interface
 * @export
 * @class MachineApi
 * @extends {BaseAPI}
 */
export class MachineApi extends BaseAPI {
    /**
     * Creates a new machine.
     * @summary Create a machine
     * @param {MachinesCreateRequest} machinesCreateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesCreate(machinesCreateRequest: MachinesCreateRequest, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesCreate(machinesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deletes a single machine by ID.
     * @summary Delete a machine
     * @param {string} id The ID of the machine to delete.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesDelete(id: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a single machine by ID.
     * @summary Get a machine
     * @param {string} id The ID of the machine to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesGet(id: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of machines.
     * @summary List machines
     * @param {string} [after] Fetch the next page of results after this cursor.
     * @param {number} [limit] The number of items to fetch after this page.
     * @param {MachinesListOrderByEnum} [orderBy] Order results by one of these fields.
     * @param {MachinesListOrderEnum} [order] The order to sort the results by.
     * @param {string} [name] 
     * @param {PublicIpsListRegionParameter} [region] 
     * @param {string} [agentType] 
     * @param {string} [machineType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesList(after?: string, limit?: number, orderBy?: MachinesListOrderByEnum, order?: MachinesListOrderEnum, name?: string, region?: PublicIpsListRegionParameter, agentType?: string, machineType?: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesList(after, limit, orderBy, order, name, region, agentType, machineType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restarts a machine.
     * @summary Restart a machine
     * @param {string} id The ID of the machine to restart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesRestart(id: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesRestart(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Starts a machine.
     * @summary Start a machine
     * @param {string} id The ID of the machine to start.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesStart(id: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesStart(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Stops a machine.
     * @summary Stop a machine
     * @param {string} id The ID of the machine to stop.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesStop(id: string, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesStop(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates a machine.
     * @summary Update a machine
     * @param {string} id The ID of the machine to update.
     * @param {MachinesUpdateRequest} machinesUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MachineApi
     */
    public machinesUpdate(id: string, machinesUpdateRequest: MachinesUpdateRequest, options?: RawAxiosRequestConfig) {
        return MachineApiFp(this.configuration).machinesUpdate(id, machinesUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MachinesListOrderByEnum = {
    DtCreated: 'dtCreated',
    Name: 'name',
    State: 'state'
} as const;
export type MachinesListOrderByEnum = typeof MachinesListOrderByEnum[keyof typeof MachinesListOrderByEnum];
/**
 * @export
 */
export const MachinesListOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MachinesListOrderEnum = typeof MachinesListOrderEnum[keyof typeof MachinesListOrderEnum];


/**
 * PublicIPsApi - axios parameter creator
 * @export
 */
export const PublicIPsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Assigns a public IP to a machine.
         * @summary Assign a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {PublicIpsAssignRequest} publicIpsAssignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsAssign: async (ip: string, publicIpsAssignRequest: PublicIpsAssignRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('publicIpsAssign', 'ip', ip)
            // verify required parameter 'publicIpsAssignRequest' is not null or undefined
            assertParamExists('publicIpsAssign', 'publicIpsAssignRequest', publicIpsAssignRequest)
            const localVarPath = `/public-ips/{ip}`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIpsAssignRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Claims a public IP.
         * @summary Claim a public IP
         * @param {PublicIpsClaimRequest} publicIpsClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsClaim: async (publicIpsClaimRequest: PublicIpsClaimRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'publicIpsClaimRequest' is not null or undefined
            assertParamExists('publicIpsClaim', 'publicIpsClaimRequest', publicIpsClaimRequest)
            const localVarPath = `/public-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publicIpsClaimRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetches a list of public IPs.
         * @summary List public IPs
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {PublicIpsListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {PublicIpsListOrderEnum} [order] The order to sort the results by.
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsList: async (after?: string, limit?: number, orderBy?: PublicIpsListOrderByEnum, order?: PublicIpsListOrderEnum, region?: PublicIpsListRegionParameter, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/public-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (after !== undefined) {
                localVarQueryParameter['after'] = after;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }

            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }

            if (region !== undefined) {
                for (const [key, value] of Object.entries(region)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Releases a public IP.
         * @summary Release a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsRelease: async (ip: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'ip' is not null or undefined
            assertParamExists('publicIpsRelease', 'ip', ip)
            const localVarPath = `/public-ips/{ip}`
                .replace(`{${"ip"}}`, encodeURIComponent(String(ip)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PublicIPsApi - functional programming interface
 * @export
 */
export const PublicIPsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PublicIPsApiAxiosParamCreator(configuration)
    return {
        /**
         * Assigns a public IP to a machine.
         * @summary Assign a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {PublicIpsAssignRequest} publicIpsAssignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicIpsAssign(ip: string, publicIpsAssignRequest: PublicIpsAssignRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIpsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicIpsAssign(ip, publicIpsAssignRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIPsApi.publicIpsAssign']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Claims a public IP.
         * @summary Claim a public IP
         * @param {PublicIpsClaimRequest} publicIpsClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicIpsClaim(publicIpsClaimRequest: PublicIpsClaimRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIpsList200ResponseItemsInner>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicIpsClaim(publicIpsClaimRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIPsApi.publicIpsClaim']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Fetches a list of public IPs.
         * @summary List public IPs
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {PublicIpsListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {PublicIpsListOrderEnum} [order] The order to sort the results by.
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicIpsList(after?: string, limit?: number, orderBy?: PublicIpsListOrderByEnum, order?: PublicIpsListOrderEnum, region?: PublicIpsListRegionParameter, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIpsList200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicIpsList(after, limit, orderBy, order, region, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIPsApi.publicIpsList']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Releases a public IP.
         * @summary Release a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publicIpsRelease(ip: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PublicIpsRelease200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.publicIpsRelease(ip, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PublicIPsApi.publicIpsRelease']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PublicIPsApi - factory interface
 * @export
 */
export const PublicIPsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PublicIPsApiFp(configuration)
    return {
        /**
         * Assigns a public IP to a machine.
         * @summary Assign a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {PublicIpsAssignRequest} publicIpsAssignRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsAssign(ip: string, publicIpsAssignRequest: PublicIpsAssignRequest, options?: any): AxiosPromise<PublicIpsList200ResponseItemsInner> {
            return localVarFp.publicIpsAssign(ip, publicIpsAssignRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Claims a public IP.
         * @summary Claim a public IP
         * @param {PublicIpsClaimRequest} publicIpsClaimRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsClaim(publicIpsClaimRequest: PublicIpsClaimRequest, options?: any): AxiosPromise<PublicIpsList200ResponseItemsInner> {
            return localVarFp.publicIpsClaim(publicIpsClaimRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetches a list of public IPs.
         * @summary List public IPs
         * @param {string} [after] Fetch the next page of results after this cursor.
         * @param {number} [limit] The number of items to fetch after this page.
         * @param {PublicIpsListOrderByEnum} [orderBy] Order results by one of these fields.
         * @param {PublicIpsListOrderEnum} [order] The order to sort the results by.
         * @param {PublicIpsListRegionParameter} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsList(after?: string, limit?: number, orderBy?: PublicIpsListOrderByEnum, order?: PublicIpsListOrderEnum, region?: PublicIpsListRegionParameter, options?: any): AxiosPromise<PublicIpsList200Response> {
            return localVarFp.publicIpsList(after, limit, orderBy, order, region, options).then((request) => request(axios, basePath));
        },
        /**
         * Releases a public IP.
         * @summary Release a public IP
         * @param {string} ip The IP address of the public IP.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publicIpsRelease(ip: string, options?: any): AxiosPromise<PublicIpsRelease200Response> {
            return localVarFp.publicIpsRelease(ip, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PublicIPsApi - object-oriented interface
 * @export
 * @class PublicIPsApi
 * @extends {BaseAPI}
 */
export class PublicIPsApi extends BaseAPI {
    /**
     * Assigns a public IP to a machine.
     * @summary Assign a public IP
     * @param {string} ip The IP address of the public IP.
     * @param {PublicIpsAssignRequest} publicIpsAssignRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIPsApi
     */
    public publicIpsAssign(ip: string, publicIpsAssignRequest: PublicIpsAssignRequest, options?: RawAxiosRequestConfig) {
        return PublicIPsApiFp(this.configuration).publicIpsAssign(ip, publicIpsAssignRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Claims a public IP.
     * @summary Claim a public IP
     * @param {PublicIpsClaimRequest} publicIpsClaimRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIPsApi
     */
    public publicIpsClaim(publicIpsClaimRequest: PublicIpsClaimRequest, options?: RawAxiosRequestConfig) {
        return PublicIPsApiFp(this.configuration).publicIpsClaim(publicIpsClaimRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fetches a list of public IPs.
     * @summary List public IPs
     * @param {string} [after] Fetch the next page of results after this cursor.
     * @param {number} [limit] The number of items to fetch after this page.
     * @param {PublicIpsListOrderByEnum} [orderBy] Order results by one of these fields.
     * @param {PublicIpsListOrderEnum} [order] The order to sort the results by.
     * @param {PublicIpsListRegionParameter} [region] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIPsApi
     */
    public publicIpsList(after?: string, limit?: number, orderBy?: PublicIpsListOrderByEnum, order?: PublicIpsListOrderEnum, region?: PublicIpsListRegionParameter, options?: RawAxiosRequestConfig) {
        return PublicIPsApiFp(this.configuration).publicIpsList(after, limit, orderBy, order, region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Releases a public IP.
     * @summary Release a public IP
     * @param {string} ip The IP address of the public IP.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PublicIPsApi
     */
    public publicIpsRelease(ip: string, options?: RawAxiosRequestConfig) {
        return PublicIPsApiFp(this.configuration).publicIpsRelease(ip, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PublicIpsListOrderByEnum = {
    DtCreated: 'dtCreated'
} as const;
export type PublicIpsListOrderByEnum = typeof PublicIpsListOrderByEnum[keyof typeof PublicIpsListOrderByEnum];
/**
 * @export
 */
export const PublicIpsListOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PublicIpsListOrderEnum = typeof PublicIpsListOrderEnum[keyof typeof PublicIpsListOrderEnum];


